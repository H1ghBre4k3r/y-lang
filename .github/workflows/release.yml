name: Release

on:
  push:
    tags:
      - "v*.*.*"

permissions:
  contents: write

env:
  CARGO_TERM_COLOR: always

jobs:
  update-version:
    name: Update Version and Amend Tag
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.extract.outputs.version }}
      is_prerelease: ${{ steps.extract.outputs.is_prerelease }}
    steps:
      - uses: actions/checkout@v5
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract version from tag
        id: extract
        run: |
          VERSION=${GITHUB_REF#refs/tags/v}
          echo "version=$VERSION" >> $GITHUB_OUTPUT

          # Check if this is a pre-release (ends with -RC)
          if [[ "$VERSION" == *-RC* ]]; then
            echo "is_prerelease=true" >> $GITHUB_OUTPUT
          else
            echo "is_prerelease=false" >> $GITHUB_OUTPUT
          fi

          echo "Extracted version: $VERSION"
          echo "Is pre-release: $([[ "$VERSION" == *-RC* ]] && echo "true" || echo "false")"

      - name: Update version in Cargo.toml files
        run: |
          VERSION=${{ steps.extract.outputs.version }}

          # Update root Cargo.toml
          sed -i 's/^version = ".*"/version = "'$VERSION'"/' Cargo.toml

          # Update workspace member
          sed -i 's/^version = ".*"/version = "'$VERSION'"/' crates/why_lib/Cargo.toml

          echo "Updated versions to $VERSION"
          echo "Root Cargo.toml version:"
          grep '^version = ' Cargo.toml
          echo "why_lib Cargo.toml version:"
          grep '^version = ' crates/why_lib/Cargo.toml

      - name: Update CHANGELOG.md
        run: |
          VERSION=${{ steps.extract.outputs.version }}
          RELEASE_DATE=$(date +%Y-%m-%d)
          IS_PRERELEASE=${{ steps.extract.outputs.is_prerelease }}

          echo "=== Updating CHANGELOG.md for version $VERSION ==="

          # Validate CHANGELOG.md exists and has expected structure
          if [ ! -f "CHANGELOG.md" ]; then
            echo "âŒ CHANGELOG.md not found!"
            exit 1
          fi

          if ! grep -q "## \[Unreleased\]" CHANGELOG.md; then
            echo "âŒ CHANGELOG.md missing [Unreleased] section!"
            exit 1
          fi

          # Check if this version already exists in changelog
          if grep -q "## \[$VERSION\]" CHANGELOG.md; then
            echo "âš ï¸  Version $VERSION already exists in CHANGELOG.md, skipping update"
          else
            echo "ðŸ“ Generating changelog entry for version $VERSION..."

            # Get the previous release tag
            PREV_TAG=$(git tag --sort=-version:refname | grep -v "v$VERSION" | head -n1)

            if [ -n "$PREV_TAG" ]; then
              echo "ðŸ“Š Generating changelog from $PREV_TAG to v$VERSION"
              COMMITS=$(git log --pretty=format:"- %s" $PREV_TAG..v$VERSION)
            else
              echo "ðŸ“Š No previous tag found, generating changelog from beginning"
              COMMITS=$(git log --pretty=format:"- %s" v$VERSION)
            fi

            if [ -z "$COMMITS" ]; then
              echo "âš ï¸  No commits found for changelog"
              COMMITS="- Release v$VERSION"
            fi

            # Create the new changelog entry
            if [ "$IS_PRERELEASE" = "true" ]; then
              ENTRY_HEADER="## [$VERSION] - $RELEASE_DATE (Pre-release)"
            else
              ENTRY_HEADER="## [$VERSION] - $RELEASE_DATE"
            fi

            echo "ðŸ“„ Creating changelog entry:"
            echo "$ENTRY_HEADER" > new_entry.md
            echo "" >> new_entry.md
            echo "### Changes" >> new_entry.md
            echo "$COMMITS" >> new_entry.md
            echo "" >> new_entry.md

            cat new_entry.md

            # Create backup before modifying
            cp CHANGELOG.md CHANGELOG.md.backup

            # Use Python to update the changelog with better error handling
            python3 << 'EOF'
          import re
          import sys

          try:
              # Read the current changelog
              with open('CHANGELOG.md', 'r') as f:
                  content = f.read()

              # Read the new entry
              with open('new_entry.md', 'r') as f:
                  new_entry = f.read()

              print("ðŸ” Searching for Unreleased section...")

              # Find the Unreleased section and clear it, then add the new entry
              unreleased_pattern = r'(## \[Unreleased\]\s*)(.*?)((?=## \[|\Z))'

              def replace_unreleased(match):
                  header = match.group(1)
                  next_section = match.group(3)

                  print("âœ… Found Unreleased section, updating...")

                  # Reset unreleased section
                  new_unreleased = """
          ### Added

          ### Changed

          ### Deprecated

          ### Removed

          ### Fixed

          ### Security

          """

                  return header + new_unreleased + "\n" + new_entry.strip() + "\n\n" + next_section

              updated_content = re.sub(unreleased_pattern, replace_unreleased, content, flags=re.DOTALL)

              # Verify the replacement worked
              if updated_content == content:
                  print("âŒ Failed to update changelog - no changes made")
                  sys.exit(1)

              # Write the updated changelog
              with open('CHANGELOG.md', 'w') as f:
                  f.write(updated_content)

              print("âœ… CHANGELOG.md updated successfully")

          except Exception as e:
              print(f"âŒ Error updating CHANGELOG.md: {e}")
              sys.exit(1)
          EOF

            # Verify the update was successful
            if [ $? -eq 0 ]; then
              if grep -q "## \[$VERSION\]" CHANGELOG.md; then
                echo "âœ… Changelog entry for v$VERSION successfully added"
                rm -f new_entry.md CHANGELOG.md.backup
              else
                echo "âŒ Changelog update failed - restoring backup"
                mv CHANGELOG.md.backup CHANGELOG.md
                exit 1
              fi
            else
              echo "âŒ Python script failed - restoring backup"
              mv CHANGELOG.md.backup CHANGELOG.md
              exit 1
            fi
          fi

          echo "=== CHANGELOG.md update completed ==="

      - name: Commit version bump and amend tag
        run: |
          VERSION=${{ steps.extract.outputs.version }}

          echo "=== Committing version changes and changelog updates ==="

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Verify files exist and have been modified
          echo "ðŸ“‹ Checking modified files:"
          git status --porcelain

          # Validate that expected files have been changed
          for file in Cargo.toml crates/why_lib/Cargo.toml CHANGELOG.md; do
            if [ ! -f "$file" ]; then
              echo "âŒ Required file $file not found!"
              exit 1
            fi
          done

          # Check if there are actually changes to commit
          if git diff --quiet HEAD -- Cargo.toml crates/why_lib/Cargo.toml CHANGELOG.md; then
            echo "âš ï¸  No changes detected in version/changelog files"
            echo "This might indicate the version was already updated"
          else
            echo "ðŸ“ Adding modified files to staging area..."
            git add Cargo.toml crates/why_lib/Cargo.toml CHANGELOG.md

            echo "ðŸ’¾ Creating commit for version v$VERSION..."
            git commit -m "chore: bump version to $VERSION and update CHANGELOG

            This commit was automatically generated by the release workflow.

            Changes:
            - Updated version in Cargo.toml files to $VERSION
            - Updated CHANGELOG.md with release notes for v$VERSION

            ðŸ¤– Generated by GitHub Actions"

            if [ $? -eq 0 ]; then
              echo "âœ… Commit created successfully"

              echo "ðŸš€ Pushing version bump commit to remote..."
              git push origin HEAD:main

              if [ $? -eq 0 ]; then
                echo "âœ… Version bump commit pushed to remote successfully"
              else
                echo "âŒ Failed to push version bump commit to remote"
                exit 1
              fi
            else
              echo "âŒ Failed to create commit"
              exit 1
            fi
          fi

          echo "ðŸ·ï¸  Moving tag v$VERSION to point to latest commit..."

          # Move the tag to point to the new commit
          git tag -fa v$VERSION -m "Release v$VERSION

          This release includes:
          - Version bumped to $VERSION in all Cargo.toml files
          - Updated CHANGELOG.md with release notes
          - Cross-platform binaries for Linux, macOS, and Windows

          ðŸ¤– Tag updated by GitHub Actions"

          if [ $? -eq 0 ]; then
            echo "âœ… Tag v$VERSION updated successfully"
          else
            echo "âŒ Failed to update tag"
            exit 1
          fi

          echo "ðŸš€ Pushing updated tag to remote..."
          git push origin v$VERSION --force

          if [ $? -eq 0 ]; then
            echo "âœ… Tag v$VERSION pushed to remote successfully"
          else
            echo "âŒ Failed to push tag to remote"
            exit 1
          fi

          echo "=== Version bump and tag update completed ==="

      - name: Validate release preparation
        run: |
          VERSION=${{ steps.extract.outputs.version }}

          echo "=== Validating release preparation for v$VERSION ==="

          # Validate version consistency across files
          echo "ðŸ” Checking version consistency..."

          ROOT_VERSION=$(grep '^version = ' Cargo.toml | sed 's/version = "\(.*\)"/\1/')
          LIB_VERSION=$(grep '^version = ' crates/why_lib/Cargo.toml | sed 's/version = "\(.*\)"/\1/')

          echo "Root Cargo.toml version: $ROOT_VERSION"
          echo "Library Cargo.toml version: $LIB_VERSION"
          echo "Expected version: $VERSION"

          if [ "$ROOT_VERSION" != "$VERSION" ]; then
            echo "âŒ Root Cargo.toml version mismatch: expected $VERSION, got $ROOT_VERSION"
            exit 1
          fi

          if [ "$LIB_VERSION" != "$VERSION" ]; then
            echo "âŒ Library Cargo.toml version mismatch: expected $VERSION, got $LIB_VERSION"
            exit 1
          fi

          echo "âœ… Version consistency check passed"

          # Validate changelog was updated
          echo "ðŸ” Checking changelog update..."

          if ! grep -q "## \[$VERSION\]" CHANGELOG.md; then
            echo "âŒ CHANGELOG.md missing entry for version $VERSION"
            exit 1
          fi

          # Check that unreleased section is properly reset
          if ! grep -A 20 "## \[Unreleased\]" CHANGELOG.md | grep -q "### Added"; then
            echo "âŒ CHANGELOG.md Unreleased section not properly structured"
            exit 1
          fi

          echo "âœ… Changelog validation passed"

          # Validate git state
          echo "ðŸ” Checking git state..."

          # Check that tag points to current commit
          TAG_COMMIT=$(git rev-list -n 1 v$VERSION)
          HEAD_COMMIT=$(git rev-parse HEAD)

          if [ "$TAG_COMMIT" != "$HEAD_COMMIT" ]; then
            echo "âŒ Tag v$VERSION does not point to HEAD commit"
            echo "Tag commit: $TAG_COMMIT"
            echo "HEAD commit: $HEAD_COMMIT"
            exit 1
          fi

          echo "âœ… Git state validation passed"

          # Show final state summary
          echo "ðŸ“Š Release preparation summary:"
          echo "   Version: $VERSION"
          echo "   Pre-release: ${{ steps.extract.outputs.is_prerelease }}"
          echo "   Commit: $HEAD_COMMIT"
          echo "   Tag: v$VERSION"

          echo "âœ… All validations passed - ready for build and release"

  create-release:
    name: Create Release
    needs: update-version
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v5
        with:
          ref: v${{ needs.update-version.outputs.version }}
          fetch-depth: 0

      - name: Generate release notes
        id: release_notes
        run: |
          VERSION=${{ needs.update-version.outputs.version }}

          echo "=== Generating release notes for v$VERSION ==="

          # Extract changelog entry from CHANGELOG.md if it exists
          if grep -q "## \[$VERSION\]" CHANGELOG.md; then
            echo "ðŸ“ Extracting changelog from CHANGELOG.md..."

            # Extract the specific version section from CHANGELOG.md
            CHANGELOG_SECTION=$(awk "/## \[$VERSION\]/{flag=1; next} /## \[/{flag=0} flag" CHANGELOG.md | sed '/^$/d')

            if [ -n "$CHANGELOG_SECTION" ]; then
              echo "âœ… Found changelog entry in CHANGELOG.md"
              CHANGELOG_SOURCE="CHANGELOG.md"
            else
              echo "âš ï¸  Empty changelog section in CHANGELOG.md, falling back to git log"
              CHANGELOG_SOURCE="git log"
            fi
          else
            echo "âš ï¸  No changelog entry found in CHANGELOG.md, using git log"
            CHANGELOG_SOURCE="git log"
          fi

          # Fallback to git log if changelog section is empty or not found
          if [ "$CHANGELOG_SOURCE" = "git log" ]; then
            PREV_TAG=$(git tag --sort=-version:refname | grep -v "v$VERSION" | head -n1)

            if [ -n "$PREV_TAG" ]; then
              echo "ðŸ“Š Generating changelog from $PREV_TAG to v$VERSION"
              COMMIT_RANGE="$PREV_TAG..v$VERSION"
            else
              echo "ðŸ“Š No previous tag found, generating changelog from beginning"
              COMMIT_RANGE="v$VERSION"
            fi

            echo "ðŸ” Finding PRs merged between $PREV_TAG and v$VERSION..."

            # Generate PR-based changelog - only include PRs, no individual commits
            CHANGELOG_SECTION="### Changes"

            # Get commits in the release range
            COMMIT_LIST=$(git rev-list --reverse $COMMIT_RANGE)

            if [ -n "$COMMIT_LIST" ]; then
              # Get all recent merged PRs to avoid repeated API calls
              echo "  Fetching recent merged PRs..."
              gh pr list --state merged --limit 50 --json number,title,url,mergeCommit > prs.json 2>/dev/null || echo "[]" > prs.json

              # Track unique PRs to avoid duplicates
              declare -A seen_prs

              # Check each commit to see if it's a PR merge commit
              for commit in $COMMIT_LIST; do
                # Try to find PR by matching merge commit SHA
                pr_match=$(grep "\"oid\":\"$commit\"" prs.json 2>/dev/null || echo "")

                if [ -n "$pr_match" ]; then
                  # Extract the PR information
                  pr_line=$(grep -B2 -A2 "\"oid\":\"$commit\"" prs.json 2>/dev/null)

                  pr_number=$(echo "$pr_line" | grep -o '"number":[0-9]*' | head -1 | cut -d: -f2)
                  pr_title=$(echo "$pr_line" | sed -n 's/.*"title":"\([^"]*\)".*/\1/p' | head -1)
                  pr_url=$(echo "$pr_line" | sed -n 's/.*"url":"\([^"]*\)".*/\1/p' | head -1)

                  # Only add if we have valid PR info and haven't seen this PR before
                  if [ -n "$pr_number" ] && [ -n "$pr_title" ] && [ -z "${seen_prs[$pr_number]}" ]; then
                    echo "  Found PR #$pr_number: $pr_title"
                    CHANGELOG_SECTION="${CHANGELOG_SECTION}"$'\n'"- [$pr_title]($pr_url) (#$pr_number)"
                    seen_prs[$pr_number]=1
                  fi
                fi
              done

              # Clean up temporary file
              rm -f prs.json
            fi

            # If no PRs were found, add a fallback
            if [ "$CHANGELOG_SECTION" = "### Changes" ]; then
              CHANGELOG_SECTION="### Changes"$'\n'"- Release v$VERSION"
            fi
          fi

          # Create comprehensive release notes
          cat > release_notes.md << EOF
          ## Release Notes

          $CHANGELOG_SECTION

          ## ðŸ“¦ Binary Downloads

          Download the appropriate binary for your platform:

          | Platform | Architecture | Download |
          |----------|--------------|----------|
          | Linux | x86_64 | \`y-lang-v$VERSION-x86_64-unknown-linux-gnu.tar.gz\` |
          | macOS | x86_64 (Intel) | \`y-lang-v$VERSION-x86_64-apple-darwin.tar.gz\` |
          | macOS | ARM64 (Apple Silicon) | \`y-lang-v$VERSION-aarch64-apple-darwin.tar.gz\` |
          | Windows | x86_64 | \`y-lang-v$VERSION-x86_64-pc-windows-msvc.zip\` |

          Each archive contains three binaries:
          - **\`yc\`** - Y Lang compiler for compiling .why source files
          - **\`yfmt\`** - Y Lang formatter for code formatting and pretty-printing
          - **\`yls\`** - Y Lang language server for IDE integration

          ## ðŸš€ Installation

          ### Option 1: Download and Extract
          1. Download the appropriate archive for your platform
          2. Extract the archive: \`tar -xzf y-lang-v$VERSION-<platform>.tar.gz\` (or unzip for Windows)
          3. Add the binaries to your PATH

          ### Option 2: Install from Source
          \`\`\`bash
          cargo install --git https://github.com/H1ghBre4k3r/y-lang --tag v$VERSION
          \`\`\`

          ## ðŸ“š Documentation

          - [Project Repository](https://github.com/H1ghBre4k3r/y-lang)
          - [Changelog](https://github.com/H1ghBre4k3r/y-lang/blob/main/CHANGELOG.md)

          ---

          **Full Changelog**: [v$VERSION](https://github.com/H1ghBre4k3r/y-lang/compare/$PREV_TAG...v$VERSION) ${PREV_TAG:+(compared to $PREV_TAG)}
          EOF

          echo "ðŸ“‹ Generated release notes:"
          echo "Source: $CHANGELOG_SOURCE"
          echo "Content preview:"
          head -20 release_notes.md

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: v${{ needs.update-version.outputs.version }}
          name: v${{ needs.update-version.outputs.version }}
          body_path: release_notes.md
          prerelease: ${{ needs.update-version.outputs.is_prerelease == 'true' }}
          generate_release_notes: false
          token: ${{ secrets.GITHUB_TOKEN }}

  build-and-release:
    name: Build and Release
    needs: [update-version, create-release]
    strategy:
      matrix:
        include:
          - target: x86_64-unknown-linux-gnu
            os: ubuntu-latest
          - target: aarch64-apple-darwin
            os: macos-latest
          # - target: x86_64-pc-windows-msvc
          #   os: windows-latest
    runs-on: ${{ matrix.os }}
    steps:
      - uses: actions/checkout@v5
        with:
          ref: v${{ needs.update-version.outputs.version }}

      - name: Install LLVM and Clang
        uses: KyleMayes/install-llvm-action@v2
        with:
          version: "18.1"
          directory: ${{ runner.temp }}/llvm

      - name: Install Ubuntu dependencies
        run: |
          sudo apt update
          wget http://security.ubuntu.com/ubuntu/pool/universe/n/ncurses/libtinfo5_6.3-2ubuntu0.1_amd64.deb
          sudo apt install ./libtinfo5_6.3-2ubuntu0.1_amd64.deb
        if: matrix.target == 'x86_64-unknown-linux-gnu'

      - name: Build and upload binaries
        uses: taiki-e/upload-rust-binary-action@v1
        with:
          bin: yc,yfmt,yls
          target: ${{ matrix.target }}
          archive: y-lang-v${{ needs.update-version.outputs.version }}-${{ matrix.target }}
          token: ${{ secrets.GITHUB_TOKEN }}
          checksum: sha256
        env:
          LLVM_SYS_181_PREFIX: ${{ env.LLVM_PATH }}
