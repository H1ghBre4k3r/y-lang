fn test(): i64 {
    x(1, 2);
}

fn main(): i64 {
    42
}

fn test2(arg1: i64, arg2: &[i64]): (i64) -> (i64, i64) {}

fn foo(func: (i64, i64) -> i64): i64 {
    let x = 2 * 3 + 4 * 5;
}

const constFoo: i64 = 42;

fn containsLambda(): void {
    let x = \(a, b, c, d) => a + b * c + d;
}

fn test3(): () {
    let x = foo();
    let y = bar(1, 2, 3);
    let z = arr[0];
    let w = nested()[42];
    let a = foor.bar.baz;
    let a = !b;
}

fn test_prefix(): () {
    let a = !true;
    let b = -5;
    let c = !flag == false;
    let d = -x + 3;
}

fn test_array(): void {
    let arr = &[1337, 42];
}

fn modify(x: &i64): void {
    x = x + 1;
}

struct Point {
x: i64;
y: i64;
}

instance Point {
    fn absolute(): i64 {
        self.x * self.y + 42
    }
}

fn takes_point(p: Point): void {
    p.absolute();
}

fn gives_point(): void {
    takes_point(Point {x: 42, y: 1337})
}
